(module srfi25/apply
   (include "array.sch")
   (import
      srfi25/shape
      srfi25/array)
   (export 
      (apply-to-vector proc::procedure vec::vector)
      (apply-to-array proc::procedure arr::%array-base)
      +srfi25/apply-unspecified+
      (apply-index-proc-to-vector proc::procedure vec::vector shape::%shape
                  #!optional (val +srfi25/apply-unspecified+))
      (apply-index-proc-to-array proc::procedure vec::%array-base shape::%shape
           #!optional (val +srfi25/apply-unspecified+))))

(define +srfi25/apply-unspecified+ '(#unspecified))

(define (srfi25/apply:val-missing? val)
   (eq? val +srfi25/apply-unspecified+))

(define-inline (vector/rank-1-array->list x)
   (cond ((vector? x)
          (vector->list x))
         ((rank-1-array? x)
          (do ((i 0 (+fx i 1))
               (res '() (cons (array-ref1 x i) res)))
              ((=fx i (array-end x 0)) (reverse! res))))
         (else
          (error "vector/rank-1-array->list" "unsupported type" x))))

(define (apply-to-vector proc::procedure vec::vector )
   (let ((len (vector-length vec)))
      (case len
         ((0)
          (proc))
         ((1)
          (proc (vector-ref vec 0)))
         ((2)
          (proc (vector-ref vec 0)
             (vector-ref vec 1)))
         ((3)
          (proc (vector-ref vec 0)
             (vector-ref vec 1)
             (vector-ref vec 2)))
         ((4)
          (proc (vector-ref vec 0)
             (vector-ref vec 1)
             (vector-ref vec 2)
             (vector-ref vec 3)))
         ((5)
          (proc (vector-ref vec 0)
             (vector-ref vec 1)
             (vector-ref vec 2)
             (vector-ref vec 3)
             (vector-ref vec 4)))
         ((6)
          (proc (vector-ref vec 0)
             (vector-ref vec 1)
             (vector-ref vec 2)
             (vector-ref vec 3)
             (vector-ref vec 4)
             (vector-ref vec 5)))
         (else
          (apply proc (vector->list vec))))))

(define (apply-to-array proc::procedure vec::%array-base)
   (let ((len (array-length vec 0)))
      (case len
         ((0)
          (proc))
         ((1)
          (proc (array-ref vec 0)))
         ((2)
          (proc (array-ref vec 0)
             (array-ref vec 1)))
         ((3)
          (proc (array-ref vec 0)
             (array-ref vec 1)
             (array-ref vec 2)))
         ((4)
          (proc (array-ref vec 0)
             (array-ref vec 1)
             (array-ref vec 2)
             (array-ref vec 3)))
         ((5)
          (proc (array-ref vec 0)
             (array-ref vec 1)
             (array-ref vec 2)
             (array-ref vec 3)
             (array-ref vec 4)))
         ((6)
          (proc (array-ref vec 0)
             (array-ref vec 1)
             (array-ref vec 2)
             (array-ref vec 3)
             (array-ref vec 4)
             (array-ref vec 5)))
         (else
          (apply proc (vector/rank-1-array->list vec))))))

(define (apply-index-proc-to-vector proc::procedure vec::vector shape::%shape
                  #!optional (val +srfi25/apply-unspecified+))
   (let ((len (vector-length vec)))
      (case len
         ((0)
          (proc shape val))
         ((1)
          (proc (vector-ref vec 0)
             shape val))
         ((2)
          (proc (vector-ref vec 0)
             (vector-ref vec 1)
             shape val))
         ((3)
          (proc (vector-ref vec 0)
             (vector-ref vec 1)
             (vector-ref vec 2)
             shape val))
         ((4)
          (proc (vector-ref vec 0)
             (vector-ref vec 1)
             (vector-ref vec 2)
             (vector-ref vec 3)
             shape val))
         ((5)
          (proc (vector-ref vec 0)
             (vector-ref vec 1)
             (vector-ref vec 2)
             (vector-ref vec 3)
             (vector-ref vec 4)
             shape val))
         ((6)
          (proc (vector-ref vec 0)
             (vector-ref vec 1)
             (vector-ref vec 2)
             (vector-ref vec 3)
             (vector-ref vec 4)
             (vector-ref vec 5)
             shape val))
         (else
          (apply proc (append! (vector->list vec) (list shape val)))))))

(define (apply-index-proc-to-array proc::procedure vec::%array-base shape::%shape
           #!optional (val +srfi25/apply-unspecified+))
   (let ((len (array-length vec 0)))
      (case len
         ((0)
          (proc shape val))
         ((1)
          (proc (array-ref vec 0)
             shape val))
         ((2)
          (proc (array-ref vec 0)
             (array-ref vec 1)
             shape val))
         ((3)
          (proc (array-ref vec 0)
             (array-ref vec 1)
             (array-ref vec 2)
             shape val))
         ((4)
          (proc (array-ref vec 0)
             (array-ref vec 1)
             (array-ref vec 2)
             (array-ref vec 3)
             shape val))
         ((5)
          (proc (array-ref vec 0)
             (array-ref vec 1)
             (array-ref vec 2)
             (array-ref vec 3)
             (array-ref vec 4)
             shape val))
         ((6)
          (proc (array-ref vec 0)
             (array-ref vec 1)
             (array-ref vec 2)
             (array-ref vec 3)
             (array-ref vec 4)
             (array-ref vec 5)
             shape val))
         (else
          (apply proc (append! (vector/rank-1-array->list vec)
                         (list shape val)))))))
