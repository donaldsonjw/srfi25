(module srfi25/array
   (include "array.sch")
   (import srfi25/shape
           srfi25/apply) 
   (export      
      (abstract-class %array-base
         startv::vector
         endv::vector
         scratch::vector)
      (final-class %array::%array-base
         coeff::vector
         store::vector)
      (final-class %shared-array::%array-base
         constants::vector
         coeffs::vector
         sscratch::vector
         backing::%array-base)
      (inline array? obj)
      (make-array shape::%shape #!optional (default #unspecified))
      (array shape::%shape #!rest vals)
      (share-array array::%array-base shape::%shape proc::procedure)
      (inline array-length array::%array-base dim::long)
      (inline array-size array::%array-base)
      (inline array-equal? arr1::%array-base arr2::%array-base)
      (inline array-rank array::%array-base)
      (inline array-start array::%array-base k::long)
      (inline array-end array::%array-base k::long)
      (inline array-shape array::%array-base)
      (inline array-ref array::%array-base #!rest indices)
      (inline array-set! array::%array-base #!rest indices+val)
      (inline array-ref2 array::%array-base i1::long i2::long)
      (inline array-set2! array::%array-base i1::long i2::long val)
      (inline array-ref1 array::%array-base i1)
      (inline array-set1! array::%array-base i1 val)
      (inline array-set0! array::%array-base val)
      (inline array-ref0 array::%array-base)
      (inline rank-1-array? x)
      (array-tabulate shp::%shape proc::procedure)
      (array-tabulate! shp::%shape proc::procedure ind)
      (array->list arr::%array-base)
      (array->vector arr::%array-base)
      (array-map! arr::%array-base x y . o)
      (array-map x y . o)
      (array-retabulate! arr::%array-base shp::%shape proc::procedure . o)
      (array-append a1::%array-base a2::%array-base #!optional (dim 0))
      (array-copy::%array-base array::%array-base)
      (array-set-w/vector! array::%array-base indices::vector val)
      (array-set-w/array! array::%array-base indices::%array-base val)
      (array-ref-w/vector array::%array-base indices::vector)
      (array-ref-w/array array::%array-base indices::%array-base)
      (array-transpose array::%array)
      (inline array-for-each-index arr::%array-base proc::procedure #!optional o)
      (array-for-each-index/arguments arr::%array-base proc::procedure)
      (array-for-each-index/vector arr::%array-base proc::procedure ind::vector)
      (array-for-each-index/array arr::%array-base proc::procedure ind::%array-base)
      (inline array-for-each arr::%array-base proc::procedure)))

(define-inline (array? obj)
   (isa? obj %array-base))


(define (make-array shp::%shape #!optional (default #unspecified))
   (receive (startv endv) (shape->startv/endv shp)
            (instantiate::%array (startv startv)
                                 (endv endv)
                                 (store (make-vector (shape-size shp)
                                           default))
                                 (coeff (shape-coefficient-vector shp))
                                 (scratch (make-vector (vector-length startv))))))

(define (array shape::%shape #!rest vals)
   (if (= (shape-size shape) (length vals))
       (let ((new-array::%array (make-array shape)))
          (let loop ((i 0)
                     (lst vals))
             (if (pair? lst)
                 (let ((curr (car lst)))
                    (vector-set! (-> new-array store) i curr)
                    (loop (+fx i 1)
                       (cdr lst)))
                 new-array)))
       (error "array" "provided values and shape are not compatible"
          (cons shape vals))))

(define-inline (array-length array::%array-base dim::long)
   (-fx (array-end array dim)
      (array-start array dim)))

(define-inline (array-size array::%array-base)
    (do ((i 0 (+fx i 1))
        (num-elements 1
           (*fx num-elements (array-length array i))))
       ((=fx i (array-rank array)) num-elements)))

(define-inline (array-equal? arr1 arr2)
   (equal? arr1 arr2))

(define (array-copy::%array-base array::%array-base)
   (let* ((res::%array (make-array (array-shape array)))
          (t (-> res scratch)))
      (array-for-each-index/vector array 
         (lambda (iv)
            (array-set-w/vector! res iv (array-ref-w/vector array iv)))
         t)
      res))

(define-inline (array-shape array::%array-base)
   (let ((res '()))
      (do ((i 0 (+fx i 1)))
          ((=fx i (array-rank array))
           (apply shape (reverse! res)))
          (set! res (cons* (array-end array i)
                       (array-start array i)
                       res)))))

(define-inline (array-rank array::%array-base)
   (vector-length (-> array startv)))

(define-inline (array-start array::%array-base k::long)
   (vector-ref (-> array startv) k))

(define-inline (array-end array::%array-base k::long)
   (vector-ref (-> array endv) k))

(define-inline (rank-1-array? x)
   (and (array? x)
        (=fx (array-rank x) 1)
        (=fx (array-start x 0) 0)))

(define-inline (array-ref0 array::%array-base)
   (if (isa? array %array)
       (let ((array::%array array))
          (vector-ref (-> array store) 0))
       ;; in the rank 0 case affine transormation is simply the constants vector
       (let ((array::%shared-array array))
          (array-ref-w/vector (-> array backing)
             (-> array constants)))))

(define (array-ref-w/vector array::%array-base indices::vector)
   (if (isa? array %array)
       (case (vector-length indices)
          ((0) (array-ref0 array))
          (else 0
           (let* ((array::%array array)
                  (t (-> array scratch))
                  (index (vector* (vector- t indices (-> array startv))
                            (-> array coeff))))
              (vector-ref (-> array store) index))))
       (let ((shared-array::%shared-array array))
          (let ((backing-index (-> shared-array backing scratch)))
             (do ((i 0 (+fx i 1)))
                 ((=fx i (vector-length backing-index))
                  (array-ref-w/vector (-> shared-array backing) backing-index))
                 
                 (vector-set! backing-index i (+fx (vector-ref (-> shared-array constants) i)
                                                 (vector* (vector-ref (-> shared-array coeffs) i)
                                                    indices))))))))

(define (array-ref-w/array array::%array-base indices::%array-base)
   (if (isa? array %array)
       (case (array-length indices 0)
          ((0)
           (array-ref0 array))
          (else
           (let* ((array::%array array)
                  (t (-> array scratch)))
              (do ((i (array-start indices 0) (+fx i 1))
                   (j 0 (+ j 1)))
                  ((=fx i (array-end indices 0)))
                  (vector-set! t j (array-ref1 indices i)))
              (let* ((t2 (vector- t t (-> array startv)))
                     (index (vector* t2
                              (-> array coeff))))
                 (vector-ref (-> array store) index)))))
       (let* ((shared-array::%shared-array array)
              (t (-> shared-array backing scratch)))
          (do ((i (array-start indices 0) (+fx i 1))
                   (j 0 (+ j 1)))
                  ((=fx i (array-end indices 0)))
                  (vector-set! t j (array-ref1 indices i)))
          (do ((i 0 (+fx i 1)))
              ((=fx i (vector-length t))
               (array-ref-w/vector (-> shared-array backing) t))
              (vector-set! t i (+fx (vector-ref (-> shared-array constants) i)
                                  (vector* (vector-ref (-> shared-array coeffs) i)
                                     t)))))))

(define-inline (array-ref1 array::%array-base i1)
   (cond ((rank-1-array? i1)
          (array-ref-w/array array i1))
         ((vector? i1)
          (array-ref-w/vector array i1))
         (else
          (if (isa? array %array)
              (let* ((array::%array array)
                     (lower (array-start array 0)))
                 (vector-ref (-> array store)
                    (-fx i1 lower)))
              (let* ((shared-array::%shared-array array)
                     (t (-> shared-array scratch)))               
                 (vector-set! t 0 i1)
                 (array-ref-w/vector array t))))))

(define-inline (array-ref2 array::%array-base i1::long i2::long)
   (if (isa? array %array)
       (let* ((array::%array array)
              (lower1 (array-start array 0))
              (lower2 (array-start array 1))
              (length2 (array-length array 1)))
          (vector-ref (-> array store)
             (+fx (*fx (-fx i1 lower1)
                     length2)
                (-fx i2 lower2))))
       (let* ((shared-array::%shared-array array)
              (t (-> shared-array scratch)))
          (vector-set! t 0 i1)
          (vector-set! t 1 i2)
          (array-ref-w/vector shared-array t))))

(define-inline (array-ref array::%array-base #!rest indices)
   (let ((len (length indices)))
      (cond  ((=fx len 0)
              (array-ref0 array))
             ((=fx len 1)
              (array-ref1 array (car indices)))
             ((=fx len 2)
              (array-ref2 array (car indices) (cadr indices)))
             ((>fx len 2)
              (array-ref-w/vector array (list->vector indices)))
             (else
              (error "array-ref" "invalid indices: "  indices)))))

(define-inline (array-set0! array::%array-base val)
   (if (isa? array %array)
       (let ((array::%array array))
          (vector-set! (-> array store) 0 val))
       ;; in the rank 0 case the affine transormation is simply the constants vector
       (let ((array::%shared-array array))
          (array-set-w/vector! (-> array backing)
             (-> array constants) val))))
 
(define (array-set-w/vector! array::%array-base indices::vector val)
   (if (=fx 0 (vector-length indices))
       (array-set0! array val)
       (if (isa? array %array)
           (let* ((array::%array array)
                  (t (-> array scratch))
                  (index (vector* (vector- t indices (-> array startv))
                            (-> array coeff))))
              (vector-set! (-> array store) index val))
           (shared-array-set-w/vector! array indices val))))

(define-inline (shared-array-set-w/vector! array::%shared-array indices::vector val)
   (let* ((backing::%array-base (-> array backing)))
      (let ((t::vector (-> array sscratch)))
         (do ((i 0 (+fx i 1)))
             ((=fx i (vector-length t))
              (array-set-w/vector! backing t val))
             (let ((j (+fx (vector-ref (-> array constants) i)
                         (vector* (vector-ref (-> array coeffs) i)
                            indices))))
                (vector-set! t i j))))))

(define (array-set-w/array! array::%array-base indices::%array-base val)
   (case (array-length indices 0)
      ((0)
       (array-set0! array val))
      (else
       (if (isa? array %array)
           (let* ((array::%array array)
                  (t (-> array scratch)))
              (do ((i (array-start indices 0) (+fx i 1))
                   (j 0 (+ j 1)))
                  ((=fx i (array-end indices 0)))
                  (vector-set! t j (array-ref1 indices i)))
              (let* ((t2 (vector- t t (-> array startv)))
                     (index (vector* t2 (-> array coeff))))
                 (vector-set! (-> array store)
                    index val)))
           (let* ((shared-array::%shared-array array)
                  (t (-> shared-array sscratch)))
              (do ((i (array-start indices 0) (+fx i 1))
                   (j 0 (+ j 1)))
                  ((=fx i (array-end indices 0)))
                  (vector-set! t j (array-ref1 indices i)))
              (do ((i 0 (+fx i 1)))
                  ((=fx i (vector-length t))
                   (array-set-w/vector! (-> shared-array backing) t val))
                  (vector-set! t i (+fx (vector-ref (-> shared-array constants) i)
                                      (vector* (vector-ref (-> shared-array coeffs) i)
                                         t)))))))))

(define-inline (array-set1! array::%array-base i1 val)
   (cond ((rank-1-array? i1)
          (array-set-w/array! array i1 val))
         ((vector? i1)
          (array-set-w/vector! array i1 val))
         (else
          (if (isa? array %array)
              (let* ((array::%array array)
                     (lower (array-start array 0)))
                 (vector-set! (-> array store)
                    (-fx i1 lower) val))
              (let ((array::%shared-array array))
                 (let ((t (make-vector (array-rank array))))
                    (vector-set! t 0 i1)
                    (array-set-w/vector! array t val)))))))

(define-inline (array-set2! array::%array-base i1::long i2::long val)
   (if (isa? array %array)
       (let* ((array::%array array)
              (lower1 (array-start array 0))
              (lower2 (array-start array 1))
              (length1 (array-length array 1)))
          (vector-set! (-> array store)
             (+fx (*fx (-fx i1 lower1)
                     length1)
                (-fx i2 lower2)) val))
       (let ((array::%shared-array array))
          (let ((t (-> array scratch)))
             (vector-set! t 0 i1)
             (vector-set! t 1 i2)
             (array-set-w/vector! array t val)))))

(define-inline (array-set! array::%array-base #!rest indices+val)
   (let ((len (length indices+val)))
      (cond ((=fx len 1)
             (array-set0! array (car indices+val)))
            ((=fx len 2)
             (array-set1! array (car indices+val)
                (cadr indices+val)))
            ((=fx len 3)
             (array-set2! array (list-ref indices+val 0) (list-ref indices+val 1)
                (list-ref indices+val 2)))
            ((>=fx len 3)
             (array-set-w/vector! array (list->vector (take indices+val (-fx len 1)))
                (list-ref indices+val (-fx len 1))))
            (else
             (error "array-set!" "invalid arguments" indices+val)))))

(define-syntax receive*
   (syntax-rules ()
      ((_ vals producer expr ...)
       (let ((vals (call-with-values (lambda () producer)
                                     (lambda args (list->vector args)))))
          expr ...))))


(define (vector-for-each proc::procedure vec::vector #!rest vecs)
   (if (null? vecs)
       (do ((i 0 (+fx i 1)))
           ((=fx i (vector-length vec)) #unspecified)
           (proc (vector-ref vec i)))
       (if (every (lambda (v) (=fx (vector-length v) (vector-length vec))) vecs)
           (do ((i 0 (+fx i 1)))
               ((=fx i (vector-length vec)) #unspecified)
               (apply proc (cons (vector-ref vec i)
                              (map (lambda (v) (vector-ref v i)) vecs))))

           (error "vector-for-each" "all vector arguments must be the same length"
              (cons vec vecs)))))


(define (affine-proc->coeffs proc rank)
   (receive* Cs (apply proc (make-list rank 0))
      (let ([cvecs (vector-map (lambda (v) (make-vector rank)) Cs)]
            [cnt   (iota rank)])
         (do ([i 0 (+fx i 1)])
             ([=fx i rank] (values Cs cvecs))
             (receive* Ks (apply proc (map (lambda (j) (if (=fx j i) 1 0)) cnt))
                (vector-for-each (lambda [v k c]
                                    (vector-set! v i (-fx k c)))
                   cvecs Ks Cs))))))

(define (share-array array::%array-base shp::%shape proc::procedure)
   (receive (constants coeffs)
      (affine-proc->coeffs proc (shape-rank shp))
      (receive (startv endv)
         (shape->startv/endv shp)
         (instantiate::%shared-array (startv startv)
                                     (endv endv)
                                     (constants constants)
                                     (coeffs coeffs)
                                     (scratch (make-vector (shape-rank shp)))
                                     (sscratch
                                        (make-vector (vector-length constants)))
                                     (backing array)))))

(define-method (object-equal? arr1::%array-base obj)
   (if (not (array? obj))
       #f
       (let ((arr2::%array-base obj))
          (and (equal?  (array-shape arr1) (array-shape arr2))
               (let* ((r (array-rank arr1))
                      (ks (make-vector r)))
                  (let loop ((d 0))
                     (if (<fx d r)
                         (let ((e (array-end arr1 d)))
                            (do ((k (array-start arr1 d) (+fx k 1))
                                 (true #t (and true (loop (+fx d 1)))))
                                ((=fx k e) true)
                                (vector-set! ks d k)))
                         (let ((res (equal? (array-ref-w/vector arr1 ks)
                                       (array-ref-w/vector arr2 ks))))
                            res))))))))


;;; array-for-each-index from arlib provided with srfi25 
(define-inline (array-for-each-index arr::%array-base proc::procedure #!optional o)
  (if o
      (array-for-each-index/arguments arr proc)
      (if (vector? o)
          (array-for-each-index/vector arr proc o)
          (array-for-each-index/array arr proc o))))

(define (array-for-each-index/arguments arr::%array-base proc::procedure)
   (let ((r::long (array-rank arr)))
      (case r
         ((0)
          (proc))
         ((1)
          (do ((i::long (array-start arr 0) (+fx i 1)))
              ((=fx i (array-end arr 0)))
              (proc i)))
         ((2)
          (do ((i::long (array-start arr 0) (+fx i 1)))
              ((=fx i (array-end arr 0)))
              (do ((j::long (array-start arr 1) (+fx j 1)))
                  ((=fx j (array-end arr 1)))
                  (proc i j))))
         (else (let ((vec (-> arr scratch)))
                  (let do-dim ((d::long 0))
                     (if (=fx d r)
                         (apply-to-vector proc vec)
                         (let ((e::long (array-end arr d)))
                            (do ((k::long (array-start arr d) (+fx k 1)))
                                ((=fx k e))
                                (vector-set! vec d k)
                                (do-dim (+fx d 1)))))))))))

(define (array-for-each-index/vector arr::%array-base proc::procedure ind::vector)
  ;; ind is a vector
   (let ((r::long (array-rank arr)))
      (case r
         ((0)
          (proc ind))
         ((1)
          (do ((i::long (array-start arr 0) (+fx i 1)))
              ((=fx i (array-end arr 0)))
              (vector-set! ind 0 i)
              (proc ind)))
         ((2)
          (do ((i::long (array-start arr 0) (+fx i 1)))
              ((=fx i (array-end arr 0)))
              (vector-set! ind 0 i)
              (do ((j::long (array-start arr 1) (+fx j 1)))
                  ((=fx j (array-end arr 1)))
                  (vector-set! ind 1 j)
                  (proc ind))))
         (else
          (let do-dim ((d::long 0))
             (if (= d r)
                 (proc ind)
                 (let ((e::long (array-end arr d)))
                    (do ((k::long (array-start arr d) (+fx k 1)))
                        ((=fx k e))
                        (vector-set! ind d k)
                        (do-dim (+fx d 1))))))))))

(define (array-for-each-index/array arr::%array-base proc::procedure ind::%array-base)
  ;; ind is an array but not a vector
   (let ((r::long (array-rank arr)))
      (case r
         ((0)
          (proc ind))
         ((1)
          (do ((i::long (array-start arr 0) (+fx i 1)))
              ((=fx i (array-end arr 0)))
              (array-set1! ind 0 i)
              (proc ind)))
         ((2)
          (do ((i::long (array-start arr 0) (+fx i 1)))
              ((=fx i (array-end arr 0)))
              (array-set1! ind 0 i)
              (do ((j::long (array-start arr 1) (+fx j 1)))
                  ((=fx j (array-end arr 1)))
                  (array-set1! ind 1 j)
                  (proc ind))))
         (else
          (let do-dim ((d::long 0))
             (if (=fx d r)
                 (proc ind)
                 (let ((e::long (array-end arr d)))
                    (do ((k::long (array-start arr d) (+fx k 1)))
                        ((=fx k e))
                        (array-set1! ind d k)
                        (do-dim (+fx d 1))))))))))

(define-inline (array-for-each arr::%array-base proc::procedure)
   (if (isa? arr %array)
       (let* ((arr::%array arr))
          (do ((i::long 0 (+fx i 1)))
              ((=fx i (vector-length (-> arr store))))
              (proc (vector-ref (-> arr store) i))))
       (let ((t (-> arr scratch)))
          (array-for-each-index/vector arr
             (lambda (v) (proc (array-ref-w/vector arr v)))
             t))))

;;; array-tabulate and friends from arlib provided with srfi25
(define (array-tabulate shp::%shape proc::procedure)
   (let ((arr (make-array shp))
         (t (make-vector (shape-rank shp))))
     (shape-for-each
        shp
        (lambda (ix)
           (array-set-w/vector! arr ix (apply-to-vector proc ix)))
        t)
     arr))
        
(define (array-tabulate! shp::%shape proc::procedure ind)
   (let ((arr (make-array shp)))
      (shape-for-each
         shp
         (lambda (ix) (array-set! arr ix (proc ix)))
         ind)
      arr))

(define (array-retabulate! arr::%array-base shp::%shape proc::procedure . o)
   (if (null? o)
       (let ((t (make-vector (shape-rank shp))))
          (shape-for-each
             shp
             (lambda (ix)
                (array-set! arr ix (apply-to-vector proc ix)))
             t))
      (shape-for-each
         shp
         (lambda (ix)
            (array-set! arr ix (proc ix)))
         (car o))))

;;; array-map and friends from arlib provided with srfi25
(define (array-map! arr::%array-base x y . o)
  (if (shape? x)
      (array-map/vector! arr x y (apply vector o))
      (array-map/vector! arr (array-shape arr) x (apply vector y o))))

(define (array-map/vector! arr::%array-base shp::%shape proc::procedure args::vector)
  (let ((rank (vector-length args)))
     (let ((argv (make-vector rank))
           (t (make-vector (shape-rank shp))))
      (shape-for-each
         shp
         (lambda (ix)
            (do ((k 0 (+fx k 1)))
                ((=fx k rank))
                (vector-set! argv k (array-ref-w/vector (vector-ref args k) ix)))
            (array-set-w/vector! arr ix (apply-to-vector proc argv)))
         t))))

(define (array-map x y . o)
  (if (shape? x)
      (let ((arr (make-array x)))
        (array-map/vector! arr x y (apply vector o))
        arr)
      (let* ((ya::%array-base y)
            (shp (array-shape ya)))
        (let ((arr (make-array shp)))
          (array-map/vector! arr shp x (apply vector y o))
          arr))))


(define (array->vector arr::%array-base)
   (let ((vec (make-vector (array-size arr))))
      (let ((k 0)
            (t (make-vector (array-rank arr))))
         (shape-for-each
            (array-shape arr)
            (lambda (index)
               (vector-set! vec k (array-ref-w/vector arr index))
               (set! k (+fx k 1)))
            t)
         vec)))

(define (array->list arr::%array-base)
   (let ((lst '())
         (t (make-vector (array-rank arr))))
      (shape-for-each
         (array-shape arr)
         (lambda (index)
            (set! lst (cons (array-ref-w/vector arr index) lst)))
         t)
      (reverse! lst)))

(define (calculate-append-shape a1::%array-base a2::%array-base dim)
   (do ((i 0 (+fx i 1))
        (res '() (cons* (if (=fx i dim)
                            (+fx (array-end a1 i)
                               (array-length a2 i))
                            (array-end a1 i))
                    (array-start a1 i)
                    res)))
       ((= i (array-rank a1))
        (apply shape (reverse! res)))))

;;; based off the implementation of array-concatenate in gauche scheme
(define (array-append a1::%array-base a2::%array-base #!optional (dim 0))
   (if  (and (=fx (array-rank a1) (array-rank a2))
             (do ((i 0 (+fx i 1))
                  (res #t (and res (=fx (array-length a1 i)
                                      (array-length a2 i)))))
                 ((or (=fx i dim)
                      (=fx i (array-rank a1))) res)))
        (let* ((new-shape (calculate-append-shape a1 a2 dim))
               (new-array (make-array new-shape))
               (t (make-vector (array-rank a1)))
               (t2 (make-vector (array-rank a2))))
           (array-for-each-index/vector a1
              (lambda (indices) (array-set-w/vector! new-array indices (array-ref-w/vector a1 indices)))
              t)
           (array-for-each-index/vector a2
              (lambda (indices)
                 (let ((new-indices (copy-vector indices (vector-length indices))))
                    (do ((i 0 (+fx i 1)))
                        ((=fx i (array-rank a1)))
                        (vector-set! new-indices i (+fx (vector-ref new-indices i)
                                                      (-fx (array-start a1 i)
                                                         (array-start a2 i)))))
                    (vector-set! new-indices dim
                       (+fx (vector-ref new-indices dim)
                          (array-length a1 dim)))
                    (array-set-w/vector! new-array new-indices (array-ref-w/vector a2 indices)))
                 new-array)
              t2)
           new-array)
        (error "array-append" "incompatible arrays" (list a1 a2))))


(define (array-transpose array::%array)
   (if (=fx (array-rank array) 2)
       (share-array array (shape (array-start array 1) (array-end array 1)
                             (array-start array 0) (array-end array 0))
          (lambda (i j) (values j i)))
       (error "array-transpose" "transpose only supported for rank 2 arrays" array)))


