(module srfi25/@type-tag@array
   ;(include "@type-tag@array.sch")
   (include "vector-utils.sch")
   (import srfi25/apply
           srfi25/array-base
           srfi25/store
           srfi25/shape
           @type-import@)
   (export      
      (inline @type-tag@array? obj)
      (make-@type-tag@array shape::%shape #!optional (default @type-default@))
      (@type-tag@array shape::%shape #!rest vals)
      (share-@type-tag@array array::%array-base shape::%shape proc::procedure)
      (inline @type-tag@array-length array::%array-base dim::long)
      (inline @type-tag@array-size array::%array-base)
      (inline @type-tag@array-equal? arr1::%array-base arr2::%array-base)
      (inline @type-tag@array-rank array::%array-base)
      (inline @type-tag@array-start array::%array-base k::long)
      (inline @type-tag@array-end array::%array-base k::long)
      (inline @type-tag@array-shape array::%array-base)
      (inline @type-tag@array-ref*::@type@ array::%array-base #!rest indices)
      (inline @type-tag@array-set*! array::%array-base #!rest indices+val)
      (inline @type-tag@array-ref2::@type@ array::%array-base i1::long i2::long)
      (inline @type-tag@array-set2! array::%array-base i1::long i2::long val::@type@)
      (@type-tag@array-ref1::@type@ array::%array-base i1)
      (@type-tag@array-set1! array::%array-base i1 val::@type@)
      (inline @type-tag@array-set0! array::%array-base val::@type@)
      (inline @type-tag@array-ref0::@type@ array::%array-base)
      (inline rank-1-@type-tag@array? x)
      (@type-tag@array-tabulate shp::%shape proc::procedure)
      (@type-tag@array-tabulate! shp::%shape proc::procedure ind)
      (@type-tag@array->list arr::%array-base)
      (@type-tag@array->vector arr::%array-base)
      (@type-tag@array-map! arr::%array-base x y . o)
      (@type-tag@array-map x y . o)
      (@type-tag@array-retabulate! arr::%array-base shp::%shape proc::procedure . o)
      (@type-tag@array-append a1::%array-base a2::%array-base #!optional (dim 0))
      (@type-tag@array-copy::%array-base array::%array-base)
      (@type-tag@array-set-w/vector! array::%array-base indices::vector val::@type@)
      (@type-tag@array-set-w/array! array::%array-base indices::%array-base val::@type@)
      (@type-tag@array-ref-w/vector::@type@ array::%array-base indices::vector)
      (@type-tag@array-ref-w/array::@type@ array::%array-base indices::%array-base)
      (@type-tag@array-transpose array::%array)
      (inline @type-tag@array-for-each-index arr::%array-base proc::procedure #!optional o)
      (@type-tag@array-for-each-index/arguments arr::%array-base proc::procedure)
      (@type-tag@array-for-each-index/vector arr::%array-base proc::procedure ind::vector)
      (@type-tag@array-for-each-index/array arr::%array-base proc::procedure ind::%array-base)
      (inline @type-tag@array-for-each arr::%array-base proc::procedure)))


;; constructors
(define  (make-@type-tag@array shp::%shape #!optional (default @type-default@))
   (receive (startv endv) (shape->startv/endv shp)
            (instantiate::%array (startv startv)
                                 (endv endv)
                                 (store (make-store (shape-size shp)
                                           :type (string->symbol "@type-tag@")
                                           :default default))
                                 (coeff (shape-coefficient-vector shp))
                                 (scratch (make-vector (vector-length startv))))))

(define (@type-tag@array shp::%shape #!rest vals)
   (if (= (shape-size shp) (length vals))
       (let ((new-array::%array (make-@type-tag@array shp)))
          (let loop ((i 0)
                     (lst vals))
             (if (pair? lst)
                 (let ((curr (car lst)))
                    (@store-set@ (-> new-array store) i curr)
                    (loop (+fx i 1)
                       (cdr lst)))
                 new-array)))
       (error "@type-tag@array" "provided values and shape are not compatible"
          (cons shape vals))))

(define-inline (@type-tag@array? obj)
   (and (isa? obj %array-base)
        (if (isa? obj %array)
            (let ((arr::%array obj))
               (eq? (store-type (-> arr store)) (string->symbol "@type-tag@")))
            (let ((shared::%shared-array obj))
               (@type-tag@array? (-> shared backing))))))

(define-inline (@type-tag@array-length array::%array-base dim::long)
   (-fx (@type-tag@array-end array dim)
      (@type-tag@array-start array dim)))

(define-inline (@type-tag@array-size array::%array-base)
   (do ((i 0 (+fx i 1))
        (num-elements 1
           (*fx num-elements (@type-tag@array-length array i))))
       ((=fx i (@type-tag@array-rank array)) num-elements)))

(define-inline (@type-tag@array-equal? arr1 arr2)
   (equal? arr1 arr2))

(define (@type-tag@array-copy array::%array-base)
   (let* ((res::%array (make-@type-tag@array (@type-tag@array-shape array)))
          (t (-> res scratch)))
      (@type-tag@array-for-each-index/vector array 
         (lambda (iv)
            (@type-tag@array-set-w/vector! res iv (@type-tag@array-ref-w/vector array iv)))
         t)
      res))

(define-inline (@type-tag@array-shape array::%array-base)
   (let ((res '()))
      (do ((i 0 (+fx i 1)))
          ((=fx i (@type-tag@array-rank array))
           (apply shape (reverse! res)))
          (set! res (cons* (@type-tag@array-end array i)
                       (@type-tag@array-start array i)
                       res)))))

(define-inline (@type-tag@array-rank array::%array-base)
   (vector-length (-> array startv)))

(define-inline (@type-tag@array-start array::%array-base k::long)
   (vector-ref (-> array startv) k))

(define-inline (@type-tag@array-end array::%array-base k::long)
   (vector-ref (-> array endv) k))


(define-inline (rank-1-@type-tag@array? x)
   (and (@type-tag@array? x)
        (=fx (@type-tag@array-rank x) 1)
        (=fx (@type-tag@array-start x 0) 0)))

(define-inline (@type-tag@array-ref0 array::%array-base)
   (if (isa? array %array)
       (let ((array::%array array))
          (@store-ref@ (-> array store) 0))
       ;; in the rank 0 case affine transormation is simply the constants vector
       (let ((array::%shared-array array))
          (@type-tag@array-ref-w/vector (-> array backing)
                           (-> array constants)))))

(define (@type-tag@array-ref-w/vector array::%array-base indices::vector)
   (if (isa? array %array)
       (case (vector-length indices)
          ((0) (@type-tag@array-ref0 array))
          (else 0
           (let* ((array::%array array)
                  (t (-> array scratch))
                  (index (vector* (vector- t indices (-> array startv))
                            (-> array coeff))))
              (@store-ref@ (-> array store) index))))
       (let ((shared-array::%shared-array array))
          (let ((backing-index (-> shared-array backing scratch)))
             (do ((i 0 (+fx i 1)))
                 ((=fx i (vector-length backing-index))
                  (@type-tag@array-ref-w/vector (-> shared-array backing) backing-index))
                 
                 (vector-set! backing-index i (+fx (vector-ref (-> shared-array constants) i)
                                                 (vector* (vector-ref (-> shared-array coeffs) i)
                                                    indices))))))))

(define (@type-tag@array-ref-w/array array::%array-base indices::%array-base)
   (if (isa? array %array)
       (case (@type-tag@array-length indices 0)
          ((0)
           (@type-tag@array-ref0 array))
          (else
           (let* ((array::%array array)
                  (t (-> array scratch)))
              (do ((i (@type-tag@array-start indices 0) (+fx i 1))
                   (j 0 (+ j 1)))
                  ((=fx i (@type-tag@array-end indices 0)))
                  (vector-set! t j (@type-tag@array-ref1 indices i)))
              (let* ((t2 (vector- t t (-> array startv)))
                     (index (vector* t2
                               (-> array coeff))))
                 (@store-ref@ (-> array store) index)))))
       (let* ((shared-array::%shared-array array)
              (t (-> shared-array backing scratch)))
          (do ((i (@type-tag@array-start indices 0) (+fx i 1))
               (j 0 (+ j 1)))
              ((=fx i (@type-tag@array-end indices 0)))
              (vector-set! t j (@type-tag@array-ref1 indices i)))
          (do ((i 0 (+fx i 1)))
              ((=fx i (vector-length t))
               (@type-tag@array-ref-w/vector (-> shared-array backing) t))
              (vector-set! t i (+fx (vector-ref (-> shared-array constants) i)
                                  (vector* (vector-ref (-> shared-array coeffs) i)
                                     t)))))))

(define (@type-tag@array-ref1 array::%array-base i1)
   (cond ((rank-1-@type-tag@array? i1)
          (@type-tag@array-ref-w/array array i1))
         ((vector? i1)
          (@type-tag@array-ref-w/vector array i1))
         (else
          (if (isa? array %array)
              (let* ((array::%array array)
                     (lower (@type-tag@array-start array 0)))
                 (@store-ref@ (-> array store)
                    (-fx i1 lower)))
              (let* ((shared-array::%shared-array array)
                     (t (-> shared-array scratch)))               
                 (vector-set! t 0 i1)
                 (@type-tag@array-ref-w/vector array t))))))

(define-inline (@type-tag@array-ref2 array::%array-base i1::long i2::long)
   (if (isa? array %array)
       (let* ((array::%array array)
              (lower1 (@type-tag@array-start array 0))
              (lower2 (@type-tag@array-start array 1))
              (length2 (@type-tag@array-length array 1)))
          (@store-ref@ (-> array store)
             (+fx (*fx (-fx i1 lower1)
                     length2)
                (-fx i2 lower2))))
       (let* ((shared-array::%shared-array array)
              (t (-> shared-array scratch)))
          (vector-set! t 0 i1)
          (vector-set! t 1 i2)
          (@type-tag@array-ref-w/vector shared-array t))))

(define-inline (@type-tag@array-ref* array::%array-base #!rest indices)
   (let ((len (length indices)))
      (cond  ((=fx len 0)
              (@type-tag@array-ref0 array))
             ((=fx len 1)
              (@type-tag@array-ref1 array (car indices)))
             ((=fx len 2)
              (@type-tag@array-ref2 array (car indices) (cadr indices)))
             ((>fx len 2)
              (@type-tag@array-ref-w/vector array (list->vector indices)))
             (else
              (error "@type-tag@array-ref*" "invalid indices: "  indices)))))

(define-inline (@type-tag@array-set0! array::%array-base val)
   (if (isa? array %array)
       (let ((array::%array array))
          (@store-set@ (-> array store) 0 val))
       ;; in the rank 0 case the affine transormation is simply the constants vector
       (let ((array::%shared-array array))
          (@type-tag@array-set-w/vector! (-> array backing)
             (-> array constants) val))))

(define (@type-tag@array-set-w/vector! array::%array-base indices::vector val)
   (if (=fx 0 (vector-length indices))
       (@type-tag@array-set0! array val)
       (if (isa? array %array)
           (let* ((array::%array array)
                  (t (-> array scratch))
                  (index (vector* (vector- t indices (-> array startv))
                            (-> array coeff))))
              (@store-set@ (-> array store) index val))
           (shared-@type-tag@array-set-w/vector! array indices val))))

(define-inline (shared-@type-tag@array-set-w/vector! array::%shared-array indices::vector val)
   (let* ((backing::%array-base (-> array backing)))
      (let ((t::vector (-> array sscratch)))
         (do ((i 0 (+fx i 1)))
             ((=fx i (vector-length t))
              (@type-tag@array-set-w/vector! backing t val))
             (let ((j (+fx (vector-ref (-> array constants) i)
                         (vector* (vector-ref (-> array coeffs) i)
                            indices))))
                (vector-set! t i j))))))

(define (@type-tag@array-set-w/array! array::%array-base indices::%array-base val)
   (case (@type-tag@array-length indices 0)
      ((0)
       (@type-tag@array-set0! array val))
      (else
       (if (isa? array %array)
           (let* ((array::%array array)
                  (t (-> array scratch)))
              (do ((i (@type-tag@array-start indices 0) (+fx i 1))
                   (j 0 (+ j 1)))
                  ((=fx i (@type-tag@array-end indices 0)))
                  (vector-set! t j (@type-tag@array-ref1 indices i)))
              (let* ((t2 (vector- t t (-> array startv)))
                     (index (vector* t2 (-> array coeff))))
                 (@store-set@ (-> array store)
                    index val)))
           (let* ((shared-array::%shared-array array)
                  (t (-> shared-array sscratch)))
              (do ((i (@type-tag@array-start indices 0) (+fx i 1))
                   (j 0 (+ j 1)))
                  ((=fx i (@type-tag@array-end indices 0)))
                  (vector-set! t j (@type-tag@array-ref1 indices i)))
              (do ((i 0 (+fx i 1)))
                  ((=fx i (vector-length t))
                   (@type-tag@array-set-w/vector! (-> shared-array backing) t val))
                  (vector-set! t i (+fx (vector-ref (-> shared-array constants) i)
                                      (vector* (vector-ref (-> shared-array coeffs) i)
                                         t)))))))))

(define (@type-tag@array-set1! array::%array-base i1 val)
   (cond ((rank-1-@type-tag@array? i1)
          (@type-tag@array-set-w/array! array i1 val))
         ((vector? i1)
          (@type-tag@array-set-w/vector! array i1 val))
         (else
          (if (isa? array %array)
              (let* ((array::%array array)
                     (lower (@type-tag@array-start array 0)))
                 (@store-set@ (-> array store)
                    (-fx i1 lower) val))
              (let ((array::%shared-array array))
                 (let ((t (make-vector (@type-tag@array-rank array))))
                    (vector-set! t 0 i1)
                    (@type-tag@array-set-w/vector! array t val)))))))

(define-inline (@type-tag@array-set2! array::%array-base i1::long i2::long val)
   (if (isa? array %array)
       (let* ((array::%array array)
              (lower1 (@type-tag@array-start array 0))
              (lower2 (@type-tag@array-start array 1))
              (length1 (@type-tag@array-length array 1)))
          (@store-set@ (-> array store)
             (+fx (*fx (-fx i1 lower1)
                     length1)
                (-fx i2 lower2)) val))
       (let ((array::%shared-array array))
          (let ((t (-> array scratch)))
             (vector-set! t 0 i1)
             (vector-set! t 1 i2)
             (@type-tag@array-set-w/vector! array t val)))))

(define-inline (@type-tag@array-set*! array::%array-base #!rest indices+val)
   (let ((len (length indices+val)))
      (cond ((=fx len 1)
             (@type-tag@array-set0! array (car indices+val)))
            ((=fx len 2)
             (@type-tag@array-set1! array (car indices+val)
                (cadr indices+val)))
            ((=fx len 3)
             (@type-tag@array-set2! array (list-ref indices+val 0) (list-ref indices+val 1)
                (list-ref indices+val 2)))
            ((>=fx len 3)
             (@type-tag@array-set-w/vector! array (list->vector (take indices+val (-fx len 1)))
                (list-ref indices+val (-fx len 1))))
            (else
             (error "@type-tag@array-set*!" "invalid arguments" indices+val)))))

; (define (vector-for-each proc::procedure vec::vector #!rest vecs)
;    (if (null? vecs)
;        (do ((i 0 (+fx i 1)))
;            ((=fx i (vector-length vec)) #unspecified)
;            (proc (vector-ref vec i)))
;        (if (every (lambda (v) (=fx (vector-length v) (vector-length vec))) vecs)
;            (do ((i 0 (+fx i 1)))
;                ((=fx i (vector-length vec)) #unspecified)
;                (apply proc (cons (vector-ref vec i)
;                               (map (lambda (v) (vector-ref v i)) vecs))))
           
;            (error "vector-for-each" "all vector arguments must be the same length"
;               (cons vec vecs)))))


(define (affine-proc->coeffs proc rank)
   (receive* Cs (apply proc (make-list rank 0))
      (let ([cvecs (vector-map (lambda (v) (make-vector rank)) Cs)]
            [cnt   (iota rank)])
         (do ([i 0 (+fx i 1)])
             ([=fx i rank] (values Cs cvecs))
             (receive* Ks (apply proc (map (lambda (j) (if (=fx j i) 1 0)) cnt))
                (vector-for-each (lambda [v k c]
                                    (vector-set! v i (-fx k c)))
                   cvecs Ks Cs))))))

(define (share-@type-tag@array array::%array-base shp::%shape proc::procedure)
   (receive (constants coeffs)
      (affine-proc->coeffs proc (shape-rank shp))
      (receive (startv endv)
         (shape->startv/endv shp)
         (instantiate::%shared-array (startv startv)
                                     (endv endv)
                                     (constants constants)
                                     (coeffs coeffs)
                                     (scratch (make-vector (shape-rank shp)))
                                     (sscratch
                                        (make-vector (vector-length constants)))
                                     (backing array)))))

;;; array-for-each-index from arlib provided with srfi25 
(define-inline (@type-tag@array-for-each-index arr::%array-base proc::procedure #!optional o)
   (let ((flag::bool o))
    (if (not flag)
        (@type-tag@array-for-each-index/arguments arr proc)
        (if (vector? o)
            (@type-tag@array-for-each-index/vector arr proc o)
            (@type-tag@array-for-each-index/array arr proc o)))))

(define (@type-tag@array-for-each-index/arguments arr::%array-base proc::procedure)
   (let ((r::long (@type-tag@array-rank arr)))
      (case r
         ((0)
          (proc))
         ((1)
          (do ((i::long (@type-tag@array-start arr 0) (+fx i 1)))
              ((=fx i (@type-tag@array-end arr 0)))
              (proc i)))
         ((2)
          (do ((i::long (@type-tag@array-start arr 0) (+fx i 1)))
              ((=fx i (@type-tag@array-end arr 0)))
              (do ((j::long (@type-tag@array-start arr 1) (+fx j 1)))
                  ((=fx j (@type-tag@array-end arr 1)))
                  (proc i j))))
         (else (let ((vec (-> arr scratch)))
                  (let do-dim ((d::long 0))
                     (if (=fx d r)
                         (apply-to-vector proc vec)
                         (let ((e::long (@type-tag@array-end arr d)))
                            (do ((k::long (@type-tag@array-start arr d) (+fx k 1)))
                                ((=fx k e))
                                (vector-set! vec d k)
                                (do-dim (+fx d 1)))))))))))

(define (@type-tag@array-for-each-index/vector arr::%array-base proc::procedure ind::vector)
   ;; ind is a vector
   (let ((r::long (@type-tag@array-rank arr)))
      (case r
         ((0)
          (proc ind))
         ((1)
          (do ((i::long (@type-tag@array-start arr 0) (+fx i 1)))
              ((=fx i (@type-tag@array-end arr 0)))
              (vector-set! ind 0 i)
              (proc ind)))
         ((2)
          (do ((i::long (@type-tag@array-start arr 0) (+fx i 1)))
              ((=fx i (@type-tag@array-end arr 0)))
              (vector-set! ind 0 i)
              (do ((j::long (@type-tag@array-start arr 1) (+fx j 1)))
                  ((=fx j (@type-tag@array-end arr 1)))
                  (vector-set! ind 1 j)
                  (proc ind))))
         (else
          (let do-dim ((d::long 0))
             (if (= d r)
                 (proc ind)
                 (let ((e::long (@type-tag@array-end arr d)))
                    (do ((k::long (@type-tag@array-start arr d) (+fx k 1)))
                        ((=fx k e))
                        (vector-set! ind d k)
                        (do-dim (+fx d 1))))))))))

(define (@type-tag@array-for-each-index/array arr::%array-base proc::procedure ind::%array-base)
   ;; ind is an array but not a vector
   (let ((r::long (@type-tag@array-rank arr)))
      (case r
         ((0)
          (proc ind))
         ((1)
          (do ((i::long (@type-tag@array-start arr 0) (+fx i 1)))
              ((=fx i (@type-tag@array-end arr 0)))
              (array-set1! ind 0 i)
              (proc ind)))
         ((2)
          (do ((i::long (@type-tag@array-start arr 0) (+fx i 1)))
              ((=fx i (@type-tag@array-end arr 0)))
              (array-set1! ind 0 i)
              (do ((j::long (@type-tag@array-start arr 1) (+fx j 1)))
                  ((=fx j (@type-tag@array-end arr 1)))
                  (array-set1! ind 1 j)
                  (proc ind))))
         (else
          (let do-dim ((d::long 0))
             (if (=fx d r)
                 (proc ind)
                 (let ((e::long (@type-tag@array-end arr d)))
                    (do ((k::long (@type-tag@array-start arr d) (+fx k 1)))
                        ((=fx k e))
                        (array-set1! ind d k)
                        (do-dim (+fx d 1))))))))))

(define-inline (@type-tag@array-for-each arr::%array-base proc::procedure)
   (if (isa? arr %array)
       (let* ((arr::%array arr))
          (do ((i::long 0 (+fx i 1)))
              ((=fx i (store-length (-> arr store))))
              (proc (store-ref (-> arr store) i))))
       (let ((t (-> arr scratch)))
          (@type-tag@array-for-each-index/vector arr
             (lambda (v) (proc (@type-tag@array-ref-w/vector arr v)))
             t))))

; array-tabulate and friends from arlib provided with srfi25
(define (@type-tag@array-tabulate shp::%shape proc::procedure)
   (let ((arr (make-@type-tag@array shp))
         (t (make-vector (shape-rank shp))))
      (shape-for-each
         shp
         (lambda (ix)
            (@type-tag@array-set-w/vector! arr ix (apply-to-vector proc ix)))
         t)
      arr))

(define (@type-tag@array-tabulate! shp::%shape proc::procedure ind)
   (let ((arr (make-@type-tag@array shp)))
      (shape-for-each
         shp
         (lambda (ix) (@type-tag@array-set1! arr ix (proc ix)))
         ind)
      arr))

(define (@type-tag@array-retabulate! arr::%array-base shp::%shape proc::procedure . o)
   (if (null? o)
       (let ((t (make-vector (shape-rank shp))))
          (shape-for-each
             shp
             (lambda (ix)
                (@type-tag@array-set1! arr ix (apply-to-vector proc ix)))
             t))
       (shape-for-each
          shp
          (lambda (ix)
             (@type-tag@array-set1! arr ix (proc ix)))
          (car o))))

; array-map and friends from arlib provided with srfi25
(define (@type-tag@array-map! arr::%array-base x y . o)
   (if (shape? x)
       (@type-tag@array-map/vector! arr x y (apply vector o))
       (@type-tag@array-map/vector! arr (@type-tag@array-shape arr) x (apply vector y o))))

(define (@type-tag@array-map/vector! arr::%array-base shp::%shape proc::procedure args::vector)
   (let ((rank (vector-length args)))
      (let ((argv (make-vector rank))
            (t (make-vector (shape-rank shp))))
         (shape-for-each
            shp
            (lambda (ix)
               (do ((k 0 (+fx k 1)))
                   ((=fx k rank))
                   (vector-set! argv k (@type-tag@array-ref-w/vector (vector-ref args k) ix)))
               (@type-tag@array-set-w/vector! arr ix (apply-to-vector proc argv)))
            t))))

(define (@type-tag@array-map x y . o)
   (if (shape? x)
       (let ((arr (make-@type-tag@array x)))
          (@type-tag@array-map/vector! arr x y (apply vector o))
          arr)
       (let* ((ya::%array-base y)
              (shp (@type-tag@array-shape ya)))
          (let ((arr (make-@type-tag@array shp)))
             (@type-tag@array-map/vector! arr shp x (apply vector y o))
             arr))))


(define (@type-tag@array->vector arr::%array-base)
   (let ((vec (make-vector (array-size arr))))
      (let ((k 0)
            (t (make-vector (array-rank arr))))
         (shape-for-each
            (array-shape arr)
            (lambda (index)
               (vector-set! vec k (@type-tag@array-ref-w/vector arr index))
               (set! k (+fx k 1)))
            t)
         vec)))

(define (@type-tag@array->list arr::%array-base)
   (let ((lst '())
         (t (make-vector (@type-tag@array-rank arr))))
      (shape-for-each
         (@type-tag@array-shape arr)
         (lambda (index)
            (set! lst (cons (@type-tag@array-ref-w/vector arr index) lst)))
         t)
      (reverse! lst)))

(define (calculate-append-shape a1::%array-base a2::%array-base dim)
   (do ((i 0 (+fx i 1))
        (res '() (cons* (if (=fx i dim)
                            (+fx (@type-tag@array-end a1 i)
                               (@type-tag@array-length a2 i))
                            (@type-tag@array-end a1 i))
                    (@type-tag@array-start a1 i)
                    res)))
       ((= i (@type-tag@array-rank a1))
        (apply shape (reverse! res)))))

; based off the implementation of array-concatenate in gauche scheme
(define (@type-tag@array-append a1::%array-base a2::%array-base #!optional (dim 0))
   (if  (and (=fx (@type-tag@array-rank a1) (@type-tag@array-rank a2))
             (do ((i 0 (+fx i 1))
                  (res #t (and res (=fx (@type-tag@array-length a1 i)
                                      (@type-tag@array-length a2 i)))))
                 ((or (=fx i dim)
                      (=fx i (@type-tag@array-rank a1))) res)))
        (let* ((new-shape (calculate-append-shape a1 a2 dim))
               (new-array (make-@type-tag@array new-shape))
               (t (make-vector (@type-tag@array-rank a1)))
               (t2 (make-vector (@type-tag@array-rank a2))))
           (@type-tag@array-for-each-index/vector a1
              (lambda (indices) (@type-tag@array-set-w/vector! new-array indices (@type-tag@array-ref-w/vector a1 indices)))
              t)
           (@type-tag@array-for-each-index/vector a2
              (lambda (indices)
                 (let ((new-indices (copy-vector indices (vector-length indices))))
                    (do ((i 0 (+fx i 1)))
                        ((=fx i (@type-tag@array-rank a1)))
                        (vector-set! new-indices i (+fx (vector-ref new-indices i)
                                                      (-fx (@type-tag@array-start a1 i)
                                                         (@type-tag@array-start a2 i)))))
                    (vector-set! new-indices dim
                       (+fx (vector-ref new-indices dim)
                          (@type-tag@array-length a1 dim)))
                    (@type-tag@array-set-w/vector! new-array new-indices (@type-tag@array-ref-w/vector a2 indices)))
                 new-array)
              t2)
           new-array)
        (error "@type-tag@array-append" "incompatible arrays" (list a1 a2))))


(define (@type-tag@array-transpose array::%array)
   (if (=fx (@type-tag@array-rank array) 2)
       (share-@type-tag@array array (shape (@type-tag@array-start array 1) (@type-tag@array-end array 1)
                                  (@type-tag@array-start array 0) (@type-tag@array-end array 0))
          (lambda (i j) (values j i)))
       (error "@type-tag@array-transpose" "transpose only supported for 2 dimensional arrays" array)))